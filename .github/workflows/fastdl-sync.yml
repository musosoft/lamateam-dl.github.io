name: Smart FastDL Sync

on:
  workflow_dispatch:
  schedule:
    - cron: '0 4 * * *' # Daily at 4 AM

permissions:
  contents: write

jobs:
  smart-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: false
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y lftp bzip2 rsync

      - name: Check Reference & Cache
        id: check_cache
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
        run: |
          set -euo pipefail
          
          # 1. Get current signature from FTP
          echo "Connecting to check Reference File (test_speakers.bsp)..."
          RAW_REF=$(lftp -u "$FTP_USER,$FTP_PASS" -e "set ssl:verify-certificate no; cd '$REMOTE_PATH'; cls -l maps/test_speakers.bsp; quit" "$FTP_HOST")
          
          # Extract Date Part (Month Day Year). Strict YYYY format expected as per user rule.
          # Regex matches: 3 letters (Month), Spaces, 1-2 Digits (Day), Spaces, 4 Digits (Year)
          # Example: "Dec 18 2025"
          CURRENT_SIG=$(echo "$RAW_REF" | grep -oE '[A-Za-z]{3}\s+[0-9]{1,2}\s+[0-9]{4}' | head -n 1 || true)
          
          echo "Current FTP Signature: '$CURRENT_SIG'"
          
          # 2. Compare with Cached Signature
          CACHE_FILE="_excludes/reference.sig"
          NEEDS_UPDATE="true"
          
          if [ -f "$CACHE_FILE" ]; then
            CACHED_SIG=$(cat "$CACHE_FILE")
            if [ "$CURRENT_SIG" == "$CACHED_SIG" ] && [ -n "$CURRENT_SIG" ]; then
              echo "‚úÖ Cache Hit! Server signature matches cached signature."
              NEEDS_UPDATE="false"
            else
              echo "‚ö†Ô∏è  Cache Miss/Expired. Server changed or first run."
            fi
          fi
          
          echo "needs_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          echo "current_sig=$CURRENT_SIG" >> $GITHUB_OUTPUT

      - name: Build Exclude Lists (If Cache Expired)
        if: steps.check_cache.outputs.needs_update == 'true'
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
          REF_SIG: ${{ steps.check_cache.outputs.current_sig }}
        run: |
          set -euo pipefail
          
          echo "::group::Generating New Exclude Lists"
          mkdir -p _excludes
          
          # Save new signature
          echo "$REF_SIG" > "_excludes/reference.sig"
          
          if [ -z "$REF_SIG" ]; then
            echo "‚ùå ERROR: No Year-based date found on test_speakers.bsp. Cannot build exclude list based on 'No Timestamp' rule."
            echo "Falling back to empty excludes (Download All Safe Mode)."
            for d in maps materials models sound resource; do : > "_excludes/${d}.txt"; done
            exit 0
          fi
          
          echo "Scanning FTP for files matching exactly: '$REF_SIG' (With NO timestamp)"

          build_list() {
            local dir=$1
            echo "Scanning $dir..."
            # Logic:
            # 1. cls -l: Get list
            # 2. awk: 
            #    - Must match REF_SIG (Same Date)
            #    - Must match /[0-9]{4}/ (Have a Year)
            #    - Must NOT match /:[0-9]{2}/ (Must NOT have a timestamp)
            lftp -u "$FTP_USER,$FTP_PASS" -e "set ssl:verify-certificate no; cd '$REMOTE_PATH'; cls -l $dir; quit" "$FTP_HOST" \
            | awk -v ref="$REF_SIG" '$0 ~ ref && $0 ~ /[0-9]{4}/ && $0 !~ /:[0-9]{2}/ { print $NF }' \
            | sort -u > "_excludes/${dir}.txt"
          }
          
          build_list "maps"
          build_list "materials"
          build_list "models"
          build_list "sound"
          
          # Resource is special, usually just overviews needed
          build_list "resource" 

          # Always exclude the test files themselves
          echo "test_speakers.bsp" >> "_excludes/maps.txt"
          echo "test_hardware.bsp" >> "_excludes/maps.txt"
          
          echo "::endgroup::"

      - name: Update Repo-Based Excludes (Always Run)
        run: |
          set -euo pipefail
          echo "::group::Merging Repo-Existing Files into Excludes"
          # Even if cache is valid, we might have new bz2 files in repo from a manual push.
          # Add them to excludes so we don't re-download them.
          
          if [ -d cstrike ]; then
            find cstrike -type f -name "*.bz2" -print0 | while IFS= read -r -d '' f; do
              rel="${f#cstrike/}"
              case "$rel" in
                maps/*) echo "${rel#maps/}" | sed 's/\.bz2$//' >> "_excludes/maps.txt" ;;
                materials/*) echo "${rel#materials/}" | sed 's/\.bz2$//' >> "_excludes/materials.txt" ;;
                models/*) echo "${rel#models/}" | sed 's/\.bz2$//' >> "_excludes/models.txt" ;;
                sound/*) echo "${rel#sound/}" | sed 's/\.bz2$//' >> "_excludes/sound.txt" ;;
                resource/*) echo "${rel#resource/}" | sed 's/\.bz2$//' >> "_excludes/resource.txt" ;;
              esac
            done
          fi
          
          # Clean up lists (sort and unique)
          for d in maps materials models sound resource; do
            if [ -f "_excludes/${d}.txt" ]; then
              sort -u -o "_excludes/${d}.txt" "_excludes/${d}.txt"
            else
              touch "_excludes/${d}.txt"
            fi
          done
          echo "::endgroup::"

      - name: üîç Log All Excluded Files
        run: |
          echo "::group::VIEW EXCLUDED FILES (Spoiler)"
          echo "--- MAPS ---"
          cat _excludes/maps.txt || true
          echo -e "\n--- MATERIALS ---"
          cat _excludes/materials.txt || true
          echo -e "\n--- MODELS ---"
          cat _excludes/models.txt || true
          echo "::endgroup::"

      - name: Mirror Custom Content
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
        run: |
          set -euo pipefail
          rm -rf _ftp
          mkdir -p _ftp/maps _ftp/materials _ftp/models _ftp/sound _ftp/resource

          echo "::group::üì• DOWNLOADING FILES (Spoiler)"
          
          # We use --exclude-glob-from to safely load the text files
          lftp -c "
            set cmd:fail-exit yes;
            set ssl:verify-certificate no;
            set ftp:passive-mode true;
            open -u '$FTP_USER','$FTP_PASS' '$FTP_HOST';
            cd '$REMOTE_PATH';

            mirror --continue --parallel=5 --verbose=1 \
              --exclude-glob-from=_excludes/maps.txt \
              --include-glob \"*.bsp\" --include-glob \"*.nav\" --include-glob \"*.res\" \
              maps _ftp/maps;

            mirror --continue --parallel=5 --verbose=1 \
              --exclude-glob-from=_excludes/materials.txt \
              --include-glob \"*.vmt\" --include-glob \"*.vtf\" \
              materials _ftp/materials;

            mirror --continue --parallel=5 --verbose=1 \
              --exclude-glob-from=_excludes/models.txt \
              --include-glob \"*.mdl\" --include-glob \"*.vvd\" --include-glob \"*.vtx\" --include-glob \"*.phy\" \
              models _ftp/models;

            mirror --continue --parallel=5 --verbose=1 \
              --exclude-glob-from=_excludes/sound.txt \
              --include-glob \"*.wav\" --include-glob \"*.mp3\" \
              sound _ftp/sound;

            mirror --continue --parallel=5 --verbose=1 \
              --exclude-glob-from=_excludes/resource.txt \
              --include-glob \"*.txt\" \
              resource _ftp/resource;
            
            quit
          "
          echo "::endgroup::"

      - name: Compress and Merge
        run: |
          set -euo pipefail
          
          mkdir -p _out
          rsync -a _ftp/ _out/

          echo "::group::üì¶ COMPRESSING FILES (Spoiler)"
          
          # Find and compress. ! -type l avoids symlink crashes.
          find _out -type f ! -type l \( \
            -name "*.bsp" -o -name "*.nav" -o -name "*.res" -o \
            -name "*.vmt" -o -name "*.vtf" -o \
            -name "*.mdl" -o -name "*.vvd" -o -name "*.vtx" -o -name "*.phy" -o \
            -name "*.wav" -o -name "*.mp3" -o \
            -name "*.txt" \
          \) -print0 | while IFS= read -r -d '' f; do
            if [ -s "$f" ]; then
              if bzip2 -z -f "$f"; then
                echo "Compressed: ${f##*/}"
              else
                echo "WARNING: Failed to compress $f"
              fi
            fi
          done
          echo "::endgroup::"

          # Merge into repo
          mkdir -p cstrike
          rsync -av _out/ cstrike/

      - name: Push Updates (Content & Cache)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "FastDL: Sync custom content"
          branch: main
          # Important: We commit cstrike/ AND _excludes/ to persist the cache
          file_pattern: "cstrike/** _excludes/**"
