name: Smart FastDL Sync

on:
  workflow_dispatch:
  schedule:
    - cron: '0 4 * * *' # Daily at 4 AM

permissions:
  contents: write

jobs:
  smart-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true             # Enabled for your large LFS maps
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y lftp bzip2 rsync

      - name: Check Reference & Cache
        id: check_cache
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
        run: |
          set -euo pipefail
          
          echo "Connecting to check Reference File (test_speakers.bsp)..."
          # Get raw listing
          RAW_REF=$(lftp -u "$FTP_USER,$FTP_PASS" -e "set ssl:verify-certificate no; cd '$REMOTE_PATH'; cls -l maps/test_speakers.bsp; quit" "$FTP_HOST")
          
          # Extract Date Part. Expecting strict YYYY format (Old/Default file).
          # Matches Month Day Year (e.g., "Dec 18 2013")
          CURRENT_SIG=$(echo "$RAW_REF" | grep -oE '[A-Za-z]{3}\s+[0-9]{1,2}\s+[0-9]{4}' | head -n 1 || true)
          
          echo "Current FTP Signature: '$CURRENT_SIG'"
          
          CACHE_FILE="_excludes/reference.sig"
          NEEDS_UPDATE="true"
          
          if [ -f "$CACHE_FILE" ]; then
            CACHED_SIG=$(cat "$CACHE_FILE")
            if [ "$CURRENT_SIG" == "$CACHED_SIG" ] && [ -n "$CURRENT_SIG" ]; then
              echo "âœ… Cache Hit! Signature unchanged."
              NEEDS_UPDATE="false"
            else
              echo "âš ï¸  Cache Miss. Server changed or first run."
            fi
          fi
          
          echo "needs_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          echo "current_sig=$CURRENT_SIG" >> $GITHUB_OUTPUT

      - name: Build Exclude Lists (If Cache Expired)
        if: steps.check_cache.outputs.needs_update == 'true'
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
          REF_SIG: ${{ steps.check_cache.outputs.current_sig }}
        run: |
          set -euo pipefail
          
          echo "::group::Generating New Exclude Lists"
          mkdir -p _excludes
          echo "$REF_SIG" > "_excludes/reference.sig"
          
          if [ -z "$REF_SIG" ]; then
            echo "âŒ ERROR: No Year-based date found. Fallback to safe mode (download nothing default)."
            # Create empty files so loop doesn't fail
            for d in maps materials models sound resource; do : > "_excludes/${d}.txt"; done
            exit 0
          fi
          
          build_list() {
            local dir=$1
            # Logic:
            # 1. Match REF_SIG (Same Date)
            # 2. Match Year Regex (Ensure it's an old file)
            # 3. NOT Match Time Regex (Ensure it doesn't have HH:MM)
            lftp -u "$FTP_USER,$FTP_PASS" -e "set ssl:verify-certificate no; cd '$REMOTE_PATH'; cls -l $dir; quit" "$FTP_HOST" \
            | awk -v ref="$REF_SIG" '$0 ~ ref && $0 ~ /[0-9]{4}/ && $0 !~ /:[0-9]{2}/ { print $NF }' \
            | sort -u > "_excludes/${dir}.txt"
          }
          
          build_list "maps"
          build_list "materials"
          build_list "models"
          build_list "sound"
          build_list "resource" 

          # Always exclude the reference files
          echo "test_speakers.bsp" >> "_excludes/maps.txt"
          echo "test_hardware.bsp" >> "_excludes/maps.txt"
          echo "::endgroup::"

      - name: Update Repo-Based Excludes
        run: |
          set -euo pipefail
          # Optimization: Don't re-download what we already have
          if [ -d cstrike ]; then
            find cstrike -type f -name "*.bz2" -print0 | while IFS= read -r -d '' f; do
              rel="${f#cstrike/}"
              case "$rel" in
                maps/*) echo "${rel#maps/}" | sed 's/\.bz2$//' >> "_excludes/maps.txt" ;;
                materials/*) echo "${rel#materials/}" | sed 's/\.bz2$//' >> "_excludes/materials.txt" ;;
                models/*) echo "${rel#models/}" | sed 's/\.bz2$//' >> "_excludes/models.txt" ;;
                sound/*) echo "${rel#sound/}" | sed 's/\.bz2$//' >> "_excludes/sound.txt" ;;
                resource/*) echo "${rel#resource/}" | sed 's/\.bz2$//' >> "_excludes/resource.txt" ;;
              esac
            done
          fi
          
          # Sort and unique all lists
          for d in maps materials models sound resource; do
            [ -f "_excludes/${d}.txt" ] && sort -u -o "_excludes/${d}.txt" "_excludes/${d}.txt" || touch "_excludes/${d}.txt"
          done

      - name: Mirror Custom Content
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USERNAME }}
          FTP_PASS: ${{ secrets.FTP_PASSWORD }}
          REMOTE_PATH: ${{ secrets.FTP_REMOTE_PATH }}
        run: |
          set -euo pipefail
          rm -rf _ftp
          mkdir -p _ftp/maps _ftp/materials _ftp/models _ftp/sound _ftp/resource

          echo "::group::ðŸ“¥ DOWNLOADING FILES"
          lftp -c "
            set cmd:fail-exit yes;
            set ssl:verify-certificate no;
            set ftp:passive-mode true;
            open -u '$FTP_USER','$FTP_PASS' '$FTP_HOST';
            cd '$REMOTE_PATH';
            
            # Using --exclude-glob-from is safe and handles spaces in filenames automatically
            
            mirror --continue --parallel=5 --verbose=1 --exclude-glob-from=_excludes/maps.txt --include-glob \"*.bsp\" --include-glob \"*.nav\" --include-glob \"*.res\" maps _ftp/maps;
            mirror --continue --parallel=5 --verbose=1 --exclude-glob-from=_excludes/materials.txt --include-glob \"*.vmt\" --include-glob \"*.vtf\" materials _ftp/materials;
            mirror --continue --parallel=5 --verbose=1 --exclude-glob-from=_excludes/models.txt --include-glob \"*.mdl\" --include-glob \"*.vvd\" --include-glob \"*.vtx\" --include-glob \"*.phy\" models _ftp/models;
            mirror --continue --parallel=5 --verbose=1 --exclude-glob-from=_excludes/sound.txt --include-glob \"*.wav\" --include-glob \"*.mp3\" sound _ftp/sound;
            mirror --continue --parallel=5 --verbose=1 --exclude-glob-from=_excludes/resource.txt --include-glob \"*.txt\" resource _ftp/resource;
            quit"
          echo "::endgroup::"

      - name: Compress and Merge
        run: |
          set -euo pipefail
          mkdir -p _out
          rsync -a _ftp/ _out/

          echo "::group::ðŸ“¦ COMPRESSING FILES"
          # Compress supported types. ! -type l avoids symlinks.
          find _out -type f ! -type l \( \
            -name "*.bsp" -o -name "*.nav" -o -name "*.res" -o \
            -name "*.vmt" -o -name "*.vtf" -o \
            -name "*.mdl" -o -name "*.vvd" -o -name "*.vtx" -o -name "*.phy" -o \
            -name "*.wav" -o -name "*.mp3" -o \
            -name "*.txt" \
          \) -print0 | while IFS= read -r -d '' f; do
            if [ -s "$f" ]; then
              # Compress. -f forces overwrite.
              bzip2 -z -f "$f" || echo "WARNING: Failed to compress $f"
            fi
          done
          echo "::endgroup::"

          mkdir -p cstrike
          # Additive sync: Add new files, update existing, DO NOT delete repo files (yet)
          rsync -av _out/ cstrike/

      - name: ðŸ§¹ Sanitize Repo (Enforce Excludes)
        run: |
          set -euo pipefail
          echo "::group::Cleaning Excluded Files from Repo"
          
          # This step proactively deletes files that are in the exclude list.
          # It fixes the issue where old/junk files (like cs_office) linger from previous runs.
          
          for type in maps materials models sound resource; do
             list="_excludes/${type}.txt"
             dir="cstrike/${type}"
             if [ -f "$list" ] && [ -d "$dir" ]; then
                count=0
                while IFS= read -r file; do
                   [ -z "$file" ] && continue
                   # Check and delete both raw and compressed versions
                   if [ -f "${dir}/${file}.bz2" ]; then
                      rm -f "${dir}/${file}.bz2"
                      count=$((count+1))
                   fi
                   if [ -f "${dir}/${file}" ]; then
                      rm -f "${dir}/${file}"
                      count=$((count+1))
                   fi
                done < "$list"
                if [ "$count" -gt 0 ]; then
                   echo "Removed $count excluded files from $type"
                fi
             fi
          done
          echo "::endgroup::"

      - name: Push Updates
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "FastDL: Sync custom content"
          branch: main
          file_pattern: "cstrike/** _excludes/**"
